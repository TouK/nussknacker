package pl.touk.nussknacker.engine.kafka.source

import pl.touk.nussknacker.engine.api.editor.DualEditorMode
import pl.touk.nussknacker.engine.api.process.ProcessObjectDependencies
import pl.touk.nussknacker.engine.flink.api.process.{FlinkContextInitializer, FlinkSource, FlinkSourceFactory}
import pl.touk.nussknacker.engine.flink.api.timestampwatermark.TimestampWatermarkHandler
import pl.touk.nussknacker.engine.kafka.serialization.KafkaDeserializationSchemaFactory
import pl.touk.nussknacker.engine.kafka.{KafkaConfig, KafkaUtils, RecordFormatter}
import org.apache.flink.types.Nothing
import org.apache.kafka.clients.consumer.ConsumerRecord
import pl.touk.nussknacker.engine.api.context.{ProcessCompilationError, ValidationContext}
import pl.touk.nussknacker.engine.api.context.transformation.{NodeDependencyValue, SingleInputGenericNodeTransformation}
import pl.touk.nussknacker.engine.api.definition._
import pl.touk.nussknacker.engine.api.typed.typing.Typed

import scala.reflect.ClassTag

/**
  * Base factory for Kafka sources with additional metadata variable.
  * It is based on [[pl.touk.nussknacker.engine.api.context.transformation.SingleInputGenericNodeTransformation]]
  * that allows custom ValidationContext and Context transformations, which are provided by [[pl.touk.nussknacker.engine.kafka.source.KafkaContextInitializer]]
 *
 * Wrapper for [[org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer]]
  * Features:
  *   - fetch latest N records which can be later used to test process in UI
  * Fetching data is defined in [[pl.touk.nussknacker.engine.kafka.source.KafkaSource]] which
  * extends [[pl.touk.nussknacker.engine.api.process.TestDataGenerator]]. See [[pl.touk.nussknacker.engine.kafka.KafkaUtils#readLastMessages]]
  *   - reset Kafka's offset to latest value - `forceLatestRead` property, see [[pl.touk.nussknacker.engine.kafka.KafkaUtils#setOffsetToLatest]]
  *
  * @param deserializationSchemaFactory - produces KafkaDeserializationSchema for raw [[pl.touk.nussknacker.engine.kafka.source.KafkaSource]]
  * @param timestampAssigner            - provides timestampAsigner and WatermarkStrategy to KafkaSource
  * @param formatter                    - support for test data parser and generator
  * @param processObjectDependencies
  * @tparam K - type of key of kafka event that is generated by raw source (SourceFunction).
  * @tparam V - type of value of kafka event that is generated by raw source (SourceFunction).
  * */
class KafkaSourceFactory[K: ClassTag, V: ClassTag](deserializationSchemaFactory: KafkaDeserializationSchemaFactory[ConsumerRecord[K, V]],
                                                   timestampAssigner: Option[TimestampWatermarkHandler[ConsumerRecord[K, V]]],
                                                   formatter: RecordFormatter,
                                                   processObjectDependencies: ProcessObjectDependencies)
  extends FlinkSourceFactory[ConsumerRecord[K, V]] with SingleInputGenericNodeTransformation[FlinkSource[ConsumerRecord[K, V]]] {

  protected val customContextInitializer: KafkaContextInitializer[K, V, DefinedParameter, State] =
    new KafkaContextInitializer[K, V, DefinedParameter, State](Typed[K], Typed[V])

  override type State = Nothing

  override def initialParameters: List[Parameter] = Parameter[String](KafkaSourceFactory.TopicParamName)
    .copy(
      editor = Some(DualParameterEditor(simpleEditor = StringParameterEditor, defaultMode = DualEditorMode.RAW)),
      validators = List(MandatoryParameterValidator, NotBlankParameterValidator)
    ) :: Nil

  override def contextTransformation(context: ValidationContext, dependencies: List[NodeDependencyValue])(implicit nodeId: ProcessCompilationError.NodeId)
  : NodeTransformationDefinition = {
    case TransformationStep(Nil, _) => NextParameters(initialParameters)
    case step@TransformationStep((KafkaSourceFactory.TopicParamName, _) :: Nil, None) =>
      FinalResults(customContextInitializer.validationContext(context, dependencies, step.parameters, step.state))
  }

  override def implementation(params: Map[String, Any], dependencies: List[NodeDependencyValue], finalState: Option[Nothing]): FlinkSource[ConsumerRecord[K, V]] = {
    val topics = List(params(KafkaSourceFactory.TopicParamName).asInstanceOf[String])
    val preparedTopics = topics.map(KafkaUtils.prepareKafkaTopic(_, processObjectDependencies))
    val kafkaConfig = KafkaConfig.parseProcessObjectDependencies(processObjectDependencies)
    KafkaUtils.validateTopicsExistence(preparedTopics, kafkaConfig)
    val deserializationSchema = deserializationSchemaFactory.create(topics, kafkaConfig)
    new KafkaSource[ConsumerRecord[K, V]](preparedTopics, kafkaConfig, deserializationSchema, timestampAssigner, formatter) {
      override val contextInitializer: FlinkContextInitializer[ConsumerRecord[K, V]] = customContextInitializer
    }
  }

  override def nodeDependencies: List[NodeDependency] = Nil
}

object KafkaSourceFactory {
  final val TopicParamName = "topic"
}

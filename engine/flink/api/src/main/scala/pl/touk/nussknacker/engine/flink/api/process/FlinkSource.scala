package pl.touk.nussknacker.engine.flink.api.process

import org.apache.flink.api.common.typeinfo.TypeInformation
import org.apache.flink.streaming.api.functions.TimestampAssigner
import org.apache.flink.streaming.api.functions.source.SourceFunction
import pl.touk.nussknacker.engine.api.MethodToInvoke
import pl.touk.nussknacker.engine.api.process.{Source, SourceFactory}
import pl.touk.nussknacker.engine.api.test.TestDataParser

/**
  * Source with methods specific for Flink
  * @tparam T - type of event that is generated by this source. This is needed to handle e.g. syntax suggestions in UI
  */
trait FlinkSource[T] extends Source[T] {

  def toFlinkSource: SourceFunction[T]

  //TODO: typeInformation&&timestampAssigner can be directly accessed from FlinkSourceFactory?
  def typeInformation: TypeInformation[T]

  def timestampAssigner : Option[TimestampAssigner[T]]

}


//Serializable to make Flink happy, e.g. kafkaMocks.MockSourceFactory won't work properly otherwise
abstract class FlinkSourceFactory[T: TypeInformation] extends SourceFactory[T] with Serializable {
  def clazz: Class[T] = typeInformation.getTypeClass

  def typeInformation: TypeInformation[T] = implicitly[TypeInformation[T]]

  def timestampAssigner : Option[TimestampAssigner[T]]

}

object FlinkSourceFactory {

  def noParam[T: TypeInformation](source: FlinkSource[T]): FlinkSourceFactory[T] =
    new NoParamSourceFactory[T](source)

  case class NoParamSourceFactory[T: TypeInformation](source: FlinkSource[T]) extends FlinkSourceFactory[T] {
    @MethodToInvoke
    def create(): Source[T] = source

    override def timestampAssigner: Option[TimestampAssigner[T]] = source.timestampAssigner
  }

}

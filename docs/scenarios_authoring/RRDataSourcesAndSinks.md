---
sidebar_position: 4
---

# Request-Response sources and sinks

## Http request as input and output to Nussknacker scenarios

### Concepts

In Request-Response mode you interact with Nussknacker Lite runtime engine in a similar way as with any "server" in the
Internet. You send request which contains request parameters and you get response from the server. The protocol for this
communication is HTTP - the same protocol is used by browsers when they communicate with web servers. One of the
differences is that the content of the communication with the Nussknacker Lite engine ("the server") is encoded as JSON,
not HTML. Not very surprisingly, in Request-Response processing mode the only possible Source component is Request and
the only Sink component is Response.

## Request-Response schema

Each scenario needs to define two schemas in [JSON Schema](/docs/scenarios_authoring/HandlingSchemas.md#json-schema) format:

- Input schema
- Output schema

Nussknacker uses these schemas to detect how the request and response should look like. Input and Output params are available on scenario properties.

![RR schema](img/rrProperties.png "RR properties")

## Request-Response source

Thanks to the [Input schema](#request-response-schema) Nussknacker knows what data to expect in the request, so it will
hint field names and will perform additional validations on SpEL expressions involving data from the selected topic.

![RR source](img/rrSource.png "RR source")

## Request-Response sink

The `response` sink configuration form will show a list of fields defined in [Input schema](#request-response-schema).

![RR sink](img/rrSink.png "RR sink")

If you prefer to define the whole response as one expression containing value of the HTTP response instead of filling
separate autogenerated fields, you can do that by switching `Raw editor` to `true`.

When using the Raw editor, you can choose the validation mode:
* strict - requires providing all fields, including optional fields, requires exact matching;
* lax - requires providing only required fields, you can skip optional fields, exact matching is not required;

(*) allowing/denying redundant fields is provided explicitly by schema property: `additionalProperties`. 
See more about how to use [JSON Schema](/docs/scenarios_authoring/HandlingSchemas.md#json-schema).

(*) exact matching describes how output validation works for types Unknown and Union. Sometimes helpers or enrichers can 
return data with type `Unknown` - it means we can't recognize the type, consequently, we have a situation difficult to handle.
And it's the place where exact matching comes to help us:

* strict mode doesn't allow to pass Unknown for any schema type. In a situation when we try to pass a value with type
  union as the output with schema union, strict mode requires these two unions should be the same;

* lax mode allows passing Unknown for any schema type. In the case of unions, lax mode requires a situation when just only one type
  of value union matches to schema union. But be aware of it, because when data will not match the output schema
  exception will be thrown on runtime. We leave the decisions to the user.


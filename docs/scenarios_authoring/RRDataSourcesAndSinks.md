---
sidebar_position: 4
---

# Request-Response sources and sinks

## Http request as input and output to Nussknacker scenarios

### Concepts

In Request-Response mode you interact with Nussknacker Lite runtime engine in a similar way as with any "server" in the
Internet. You send request which contains request parameters and you get response from the server. The protocol for this
communication is HTTP - the same protocol is used by browsers when they communicate with web servers. One of the
differences is that the content of the communication with the Nussknacker Lite engine ("the server") is encoded as JSON,
not HTML. Not very surprisingly, in Request-Response processing mode the only possible Source component is Request and
the only Sink component is Response.

## Request-Response schema

Each scenario needs to define two schemas in [JSON Schema](/docs/scenarios_authoring/HandlingSchemas.md#json-schema) format:

- Input schema
- Output schema

Nussknacker uses these schemas to detect how the request and response should look like. Input and Output params are available on scenario properties.

![RR schema](img/rrProperties.png "RR properties")

## Request-Response source

Thanks to the [Input schema](#request-response-schema) Nussknacker knows what data to expect in the request, so it will
hint field names and will perform additional validations on SpEL expressions involving data from the selected topic.

![RR source](img/rrSource.png "RR source")

## Request-Response sink

The `response` sink configuration form will show a list of fields defined in [Input schema](#request-response-schema).

![RR sink](img/rrSink.png "RR sink")

If you prefer to define the whole response as one expression containing value of the HTTP response instead of filling
separate autogenerated fields, you can do that by switching `Raw editor` to `true`.

When using the Raw editor, you can choose the validation mode:
* strict - requires providing all fields, including optional fields, requires exact matching;
* lax - requires providing only required fields, you can skip optional fields, exact matching is not required;

(*) allowing/denying redundant fields is provided explicit by schema property: `additionalProperties`. 
See more how to use [JSON Schema](/docs/scenarios_authoring/HandlingSchemas.md#json-schema).

(*) exact matching describes how output validation works for types Unknown and Union. Sometimes helpers or enrichers can
return data  with type `Unknown` - it means we can't recognize type, consequently we have situation difficult to handle.
And it's the place where exact matching comes to help us:

* strict mode doesn't allow to pass Unknown for any schema type. In situation when wy try to pass value with type
  union as the output with schema union, strict mode requires these two unions should be the same;

* lax mode allow to pass Unknown for any schema type. In case of unions, lax mode requires situation when just only one type
  from value union matches to schema union. But be aware of it, because when data will not match to the output schema
  exception will be thrown on runtime. We leave the decisions to the user.
